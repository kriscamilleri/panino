Let's continue our work on the markdown rendering in our Print outs. The full stops and commas are strangely aligned. When I use different fonts it clips on existing letters, with Roboto there is too much space. It doesn't seem to affect letters and numbers or most special characters. 

Please output the entirety of any new or modified files.

 CODE:

----- START: /home/kris/Development/panino/frontend/package.json -----
{
  "name": "pn-markdown-notes",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@vlcn.io/crsqlite-wasm": "^0.16.0",
    "@vueuse/core": "^10.11.0",
    "dompurify": "^3.1.5",
    "events": "^3.3.0",
    "file-saver": "^2.0.5",
    "html2canvas": "^1.4.1",
    "jspdf": "^2.5.1",
    "jszip": "^3.10.1",
    "lodash-es": "^4.17.21",
    "lucide-vue-next": "^0.395.0",
    "markdown-it": "^14.1.0",
    "markdown-it-task-lists": "^2.1.1",
    "pinia": "^2.1.7",
    "uuid": "^9.0.1",
    "vue": "^3.4.27",
    "vue-router": "^4.3.2"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^5.0.5",
    "autoprefixer": "^10.4.19",
    "postcss": "^8.4.38",
    "tailwindcss": "^3.4.3",
    "vite": "^5.3.1"
  }
}
----- END: /home/kris/Development/panino/frontend/package.json -----

----- START: /home/kris/Development/panino/frontend/src/components/StyleCustomizer.vue -----
<template>
  <div class="min-h-screen bg-gray-50 flex flex-col">
    <AccountNav :title="config.title">
      <template #actions>
        <button @click="toggleStylesCustomization"
          class="px-3 py-1.5 text-sm font-medium text-gray-700 bg-gray-100 border border-gray-200 rounded-md hover:bg-gray-200 flex items-center space-x-2"
          :class="{ 'bg-gray-200': showStylesCustomization }">
          <Settings class="w-4 h-4" />
          <span>{{ showStylesCustomization ? 'Hide' : 'Show' }} Styles</span>
        </button>
        <button @click="goBack"
          class="px-3 py-1.5 text-sm font-medium text-gray-700 bg-gray-100 border border-gray-200 rounded-md hover:bg-gray-200 flex items-center space-x-2">
          <ArrowLeft class="w-4 h-4" />
          <span>Back</span>
        </button>
      </template>
    </AccountNav>

    <div class="flex-1 flex overflow-hidden">
      <div v-if="showStylesCustomization" class="w-1/2 p-8 overflow-y-auto" :style="{ height: 'calc(100vh - 57px)' }">
        <div class="bg-white shadow-lg rounded-lg p-8 h-full overflow-y-auto">
          <div class="space-y-6">
            <div v-for="(styles, category) in categorizedStyles" :key="category" class="space-y-4">
              <h2 class="text-lg font-semibold text-gray-700 border-b pb-2">
                {{ category }}
              </h2>
              <div v-for="(value, key) in styles" :key="key" class="space-y-2">
                <label :for="key" class="block text-sm font-medium text-gray-700">
                  {{ key }}
                </label>
                <textarea :id="key" v-model="editableStyleMap[key]" @input="handleStyleChange(key, $event.target.value)"
                  class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-gray-500 focus:border-gray-500 sm:text-sm font-mono"
                  rows="3" :placeholder="`CSS styles for ${key} element`" />
              </div>
            </div>

            <div v-if="config.extraFields?.length" class="space-y-4 pt-8 border-t">
              <h2 class="text-lg font-semibold text-gray-700">
                {{ config.extraFieldsTitle || 'Additional Settings' }}
              </h2>
              <div v-for="field in config.extraFields" :key="field.id" class="space-y-2">
                <label :for="field.id" class="block text-sm font-medium text-gray-700">
                  {{ field.label }}
                </label>

                <div v-if="field.id === 'googleFontFamily'" class="font-selector-container space-y-2">
                  <div class="flex flex-wrap gap-2 p-3 border border-gray-300 rounded-md bg-gray-50 min-h-[2.5rem]">
                    <span v-for="font in selectedFonts" :key="font"
                      class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-blue-100 text-blue-800">
                      {{ font }}
                      <button @click="removeFont(font)" class="ml-1 text-blue-600 hover:text-blue-800 font-bold">
                        ×
                      </button>
                    </span>
                    <input v-model="fontSearchQuery" @input="searchFonts" @keydown="handleFontInputKeydown"
                      @focus="showFontDropdown = true" placeholder="Search Google Fonts..."
                      class="flex-1 min-w-[120px] border-none outline-none bg-transparent text-sm" />
                  </div>
                  <div v-if="showFontDropdown && filteredFonts.length"
                    class="absolute z-50 w-full max-w-md bg-white border border-gray-300 rounded-md shadow-lg max-h-60 overflow-y-auto">
                    <div v-for="font in filteredFonts.slice(0, 50)" :key="font" @click="addFont(font)"
                      class="px-3 py-2 hover:bg-gray-100 cursor-pointer text-sm border-b border-gray-100 last:border-b-0">
                      {{ font }}
                    </div>
                  </div>
                </div>

                <textarea v-else-if="field.type === 'textarea'" :id="field.id" :rows="field.rows || 4"
                  v-model="editableStyleMap[field.modelKey]"
                  @input="handleStyleChange(field.modelKey, $event.target.value)"
                  class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-gray-500 focus:border-gray-500 sm:text-sm font-mono"
                  :placeholder="field.placeholder" />

                <input v-else-if="field.type === 'input'" :id="field.id" :type="field.inputType || 'text'"
                  v-model="editableStyleMap[field.modelKey]"
                  @input="handleStyleChange(field.modelKey, $event.target.value)"
                  class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-gray-500 focus:border-gray-500 sm:text-sm"
                  :class="field.inputType === 'color' ? 'h-10' : ''" :placeholder="field.placeholder" />

                <select v-else-if="field.type === 'select'" :id="field.id" v-model="editableStyleMap[field.modelKey]"
                  @change="handleStyleChange(field.modelKey, $event.target.value)"
                  class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-gray-500 focus:border-gray-500 sm:text-sm">
                  <option v-for="opt in field.options" :key="opt.value" :value="opt.value">
                    {{ opt.text }}
                  </option>
                </select>

                <div v-else-if="field.type === 'checkbox'" class="flex items-center">
                  <input :id="field.id" type="checkbox" :checked="editableStyleMap[field.modelKey] === true ||
                    editableStyleMap[field.modelKey] === 'true'
                    " @change="handleStyleChange(field.modelKey, $event.target.checked)"
                    class="h-4 w-4 text-gray-600 border-gray-300 rounded focus:ring-gray-500" />
                </div>
              </div>
            </div>
          </div>

          <hr class="my-6" />
          <button @click="resetStyles"
            class="px-4 py-2 text-red-700 bg-red-50 hover:bg-red-100 rounded flex items-center space-x-2 border border-red-200">
            <span>Reset to Defaults</span>
          </button>
        </div>
      </div>

      <div :class="showStylesCustomization ? 'w-1/2' : 'w-full'" class="bg-white border-l overflow-hidden"
        :style="{ height: 'calc(100vh - 57px)' }">
        <slot />
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, watch, onMounted, onUnmounted } from 'vue';
import { useRouter } from 'vue-router';
import { ArrowLeft, Settings } from 'lucide-vue-next';
import { useDebounceFn } from '@vueuse/core';
import AccountNav from './AccountNav.vue';

const props = defineProps({
  /** 
   * config must provide:
   *  - title: string
   *  - getStyles(): object
   *  - updateStyleAction(key, value): void
   *  - styleCategories: Record<string, string[]>
   *  - extraFields?: Array<{ id, label, type, modelKey, … }>
   *  - extraFieldsTitle?: string
   *  - resetStyles(): void
   *  - onBack?(): void
   */
  config: { type: Object, required: true }
});

const router = useRouter();
const editableStyleMap = ref({});
const showStylesCustomization = ref(false);

// Google-font picker state
const selectedFonts = ref([]);
const fontSearchQuery = ref('');
const showFontDropdown = ref(false);
const allGoogleFonts = ref([]);
const filteredFonts = ref([]);

const popularGoogleFonts = [
  'Inter', 'Roboto', 'Open Sans', 'Lato', 'Montserrat', 'Source Sans Pro', 'Raleway', 'PT Sans',
  'Libre Baskerville', 'Merriweather', 'Playfair Display', 'Georgia', 'Times New Roman', 'Arial',
  'Helvetica', 'Poppins', 'Nunito', 'Work Sans', 'Fira Sans', 'Oswald', 'Dancing Script', 'Lobster',
  'Pacifico', 'Quicksand', 'Ubuntu', 'Droid Sans', 'Roboto Condensed', 'Cabin', 'Lora', 'Crimson Text',
  'Noto Sans', 'Mukti', 'Source Code Pro', 'JetBrains Mono', 'Fira Code', 'Inconsolata', 'IBM Plex Sans',
  'IBM Plex Serif', 'IBM Plex Mono', 'Barlow', 'DM Sans', 'Rubik', 'Karla', 'Oxygen', 'PT Serif',
  'Titillium Web', 'Muli', 'Exo', 'Comfortaa', 'Archivo', 'Hind', 'Bitter', 'Josefin Sans'
];

// debounce calls to store
const debouncedUpdateStore = useDebounceFn((k, v) => props.config.updateStyleAction(k, v), 300);

onMounted(() => {
  allGoogleFonts.value = [...popularGoogleFonts];
  document.addEventListener('click', handleClickOutside);
});

onUnmounted(() => {
  document.removeEventListener('click', handleClickOutside);
  // clean up injected <style id="markdown-custom-styles">
  const s = document.getElementById('markdown-custom-styles');
  if (s) s.remove();
});

function handleClickOutside(e) {
  if (!e.target.closest('.font-selector-container')) {
    showFontDropdown.value = false;
  }
}

function searchFonts() {
  const q = fontSearchQuery.value.trim().toLowerCase();
  if (!q) {
    filteredFonts.value = allGoogleFonts.value.filter(f => !selectedFonts.value.includes(f));
  } else {
    const matches = allGoogleFonts.value.filter(f =>
      f.toLowerCase().includes(q) && !selectedFonts.value.includes(f)
    );
    const exact = allGoogleFonts.value.find(f => f.toLowerCase() === q);
    if (!exact && q.length > 2) {
      const fmt = q
        .split(' ')
        .map(w => w[0].toUpperCase() + w.slice(1))
        .join(' ');
      if (!selectedFonts.value.includes(fmt)) matches.unshift(fmt);
    }
    filteredFonts.value = matches;
  }
  showFontDropdown.value = !!filteredFonts.value.length;
}

function addFont(f) {
  if (!selectedFonts.value.includes(f)) {
    selectedFonts.value.push(f);
    updateGoogleFontFamily();
  }
  fontSearchQuery.value = '';
  filteredFonts.value = [];
  showFontDropdown.value = false;
}

function removeFont(f) {
  const i = selectedFonts.value.indexOf(f);
  if (i > -1) {
    selectedFonts.value.splice(i, 1);
    updateGoogleFontFamily();
  }
}

function updateGoogleFontFamily() {
  const fam = selectedFonts.value.join(', ');
  handleStyleChange('googleFontFamily', fam);
}

function handleFontInputKeydown(e) {
  if (e.key === 'Enter' && fontSearchQuery.value.trim()) {
    const fmt = fontSearchQuery.value
      .trim()
      .split(' ')
      .map(w => w[0].toUpperCase() + w.slice(1))
      .join(' ');
    if (!selectedFonts.value.includes(fmt)) addFont(fmt);
    e.preventDefault();
  } else if (e.key === 'Escape') {
    showFontDropdown.value = false;
    fontSearchQuery.value = '';
  }
}

// Initialize local map whenever store styles change
watch(
  () => props.config.getStyles(),
  newStyles => {
    const proc = { ...newStyles };
    // coerce checkbox fields
    props.config.extraFields?.forEach(f => {
      if (f.type === 'checkbox' && typeof proc[f.modelKey] !== 'boolean') {
        proc[f.modelKey] = String(proc[f.modelKey]).toLowerCase() === 'true';
      }
    });
    editableStyleMap.value = proc;

    // extract googleFontFamily into chips
    const gf = proc.googleFontFamily || '';
    if (gf) {
      const fonts = gf
        .split(',')
        .map(x => x.trim().replace(/['"]/g, ''))
        .filter(x => x && !['sans-serif', 'serif', 'monospace'].includes(x));
      selectedFonts.value = fonts;
    } else {
      selectedFonts.value = [];
    }
  },
  { deep: true, immediate: true }
);

function handleStyleChange(key, val) {
  editableStyleMap.value[key] = val;
  debouncedUpdateStore(key, val);
}

function resetStyles() {
  if (
    confirm(
      'Are you sure you want to reset all styles to their default values? This action cannot be undone.'
    )
  ) {
    props.config.resetStyles();
  }
}

function toggleStylesCustomization() {
  showStylesCustomization.value = !showStylesCustomization.value;
}

const categorizedStyles = computed(() => {
  if (!props.config.styleCategories) return {};
  const extraKeys = props.config.extraFields?.map(f => f.modelKey) || [];
  return Object.entries(props.config.styleCategories).reduce((acc, [cat, keys]) => {
    const entries = keys
      .filter(k => editableStyleMap.value.hasOwnProperty(k) && !extraKeys.includes(k))
      .map(k => [k, editableStyleMap.value[k]]);
    if (entries.length) acc[cat] = Object.fromEntries(entries);
    return acc;
  }, {});
});

function goBack() {
  if (props.config.onBack) {
    props.config.onBack();
  } else {
    router.push('/');
  }
}
</script>

<style scoped>
.font-selector-container {
  position: relative;
}

.font-selector-container .absolute {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
}
</style>
----- END: /home/kris/Development/panino/frontend/src/components/StyleCustomizer.vue -----

----- START: /home/kris/Development/panino/frontend/src/components/SubMenuBar.vue -----
<template>
    <transition name="fade-fast" mode="out-in">
        <div v-if="ui.isAnyMenuOpen"
            class="border-t bg-gray-50 px-4 py-2 min-h-[40px] flex items-center overflow-x-auto"
            data-testid="submenu-bar">
            <div v-if="ui.showViewMenu" class="flex flex-wrap gap-2" key="view">
                <BaseButton :isActive="ui.showDocuments" @click="ui.toggleDocuments()"
                    data-testid="submenu-view-documents">

                    <Folder class="w-4 h-4" /><span>Documents</span>

                </BaseButton>

                <BaseButton :isActive="ui.showEditor" @click="ui.toggleEditor()" data-testid="submenu-view-editor">

                    <Edit3 class="w-4 h-4" /><span>Editor</span>

                </BaseButton>

                <BaseButton :isActive="ui.showPreview" @click="ui.togglePreview()" data-testid="submenu-view-preview">

                    <Eye class="w-4 h-4" /><span>Preview</span>

                </BaseButton>

                <BaseButton @click="goToStyles" data-testid="submenu-view-styles">

                    <Palette class="w-4 h-4" /><span>Preview Styles</span>

                </BaseButton>
            </div>

            <div v-else-if="ui.showActionBar" class="flex flex-wrap gap-2" key="document">
                <button v-for="format in textFormats" :key="format.label" @click="insertFormat(format)"
                    class="px-3 py-1 bg-white border rounded hover:bg-gray-50 text-sm flex items-center gap-1 cursor-pointer"
                    :title="format.label" :data-testid="`submenu-document-${format.label.toLowerCase()}`">

                    <component :is="format.icon" class="w-4 h-4" /><span>{{ format.label }}</span>

                </button>

                <div class="w-px h-6 bg-gray-300 mx-2"></div>

                <button v-for="list in listFormats" :key="list.label" @click="insertList(list)"
                    class="px-3 py-1 bg-white border rounded hover:bg-gray-50 text-sm flex items-center gap-1 cursor-pointer"
                    :title="list.label" :data-testid="`submenu-document-${list.label.toLowerCase().replace(' ', '-')}`">

                    <component :is="list.icon" class="w-4 h-4" /><span>{{ list.label }}</span>

                </button>

                <div class="w-px h-6 bg-gray-300 mx-2"></div>

                <button @click="insertTable"
                    class="px-3 py-1 bg-white border rounded hover:bg-gray-50 text-sm flex items-center gap-1"
                    title="Insert Table" data-testid="submenu-document-table">

                    <Table class="w-4 h-4" />
                    <span>Table</span>

                </button>

                <button @click="insertCodeBlock"
                    class="px-3 py-1 bg-white border rounded hover:bg-gray-50 text-sm flex items-center gap-1"
                    title="Insert Code Block" data-testid="submenu-document-code">

                    <Code2 class="w-4 h-4" /><span>Code</span>

                </button>

                <div class="w-px h-6 bg-gray-300 mx-2"></div>

                <button @click="insertImagePlaceholder"
                    class="px-3 py-1 bg-white border rounded hover:bg-gray-50 text-sm flex items-center gap-1"
                    title="Insert Image Markdown" data-testid="submenu-document-image-placeholder">

                    <ImageIcon class="w-4 h-4" /><span>Image</span>

                </button>

                <button @click="openImageDialog"
                    class="px-3 py-1 bg-white border rounded hover:bg-gray-50 text-sm flex items-center gap-1"
                    title="Insert Image From File" data-testid="submenu-document-image-upload">

                    <Upload class="w-4 h-4" /><span>Image&nbsp;from&nbsp;File</span>

                </button>
                <input ref="imageInput" type="file" accept="image/*" class="hidden" @change="handleImageSelect" />

                <div class="w-px h-6 bg-gray-300 mx-2"></div>

                <div class="flex items-center gap-2">
                    <div class="relative">

                        <Search class="absolute left-2 top-1.5 w-4 h-4 text-gray-400" />
                        <input type="text" placeholder="Find..." v-model="searchTerm"
                            class="border pl-7 pr-2 py-1 rounded text-sm w-36 focus:outline-none focus:border-gray-500"
                            data-testid="submenu-document-search-input" @keyup.enter="findNext(searchTerm)" />

                    </div>
                    <button @click="findNext(searchTerm)"
                        class="px-2 py-1 bg-white border rounded hover:bg-gray-50 text-sm flex items-center gap-1"
                        data-testid="submenu-document-search-next">

                        <ArrowRight class="w-4 h-4" /><span>Next</span>

                    </button>

                    <div class="flex items-center gap-1 ml-4">
                        <input id="replaceEnabled" type="checkbox" v-model="replaceEnabled"
                            data-testid="submenu-document-replace-checkbox" />
                        <label for="replaceEnabled" class="text-sm select-none">Replace</label>
                    </div>

                    <template v-if="replaceEnabled">
                        <input type="text" placeholder="Replacement…" v-model="replaceTerm"
                            class="border px-2 py-1 rounded text-sm w-36 focus:outline-none focus:border-gray-500"
                            data-testid="submenu-document-replace-input"
                            @keyup.enter="replaceNext(searchTerm, replaceTerm)" />

                        <button @click="replaceNext(searchTerm, replaceTerm)"
                            class="px-2 py-1 bg-white border rounded hover:bg-gray-50 text-sm flex items-center gap-1"
                            data-testid="submenu-document-replace-next">

                            <Replace class="w-4 h-4" /><span>Go</span>

                        </button>

                        <button @click="replaceAll(searchTerm, replaceTerm)"
                            class="px-2 py-1 bg-white border rounded hover:bg-gray-50 text-sm flex items-center gap-1"
                            data-testid="submenu-document-replace-all">

                            <Replace class="w-4 h-4" /><span>All</span>

                        </button>
                    </template>
                </div>
                <BaseButton :isActive="ui.showStats" @click="ui.toggleStats()" data-testid="submenu-document-stats">

                    <BarChart2 class="w-4 h-4" /><span>Stats</span>

                </BaseButton>
                <BaseButton :isActive="ui.showMetadata" @click="ui.toggleMetadata()"
                    data-testid="submenu-document-info">

                    <Info class="w-4 h-4" /><span>Info</span>

                </BaseButton>

                <div class="w-px h-6 bg-gray-300 mx-2"></div>
            </div>

            <div v-else-if="ui.showFileMenu" class="flex flex-wrap gap-2" key="file">
                <BaseButton @click="ui.openImportModal()" data-testid="submenu-tools-import-json">

                    <Upload class="w-4 h-4" /><span>Import JSON</span>

                </BaseButton>

                <BaseButton @click="handleExport" data-testid="submenu-tools-export-json">

                    <FileJson class="w-4 h-4" /><span>Export JSON</span>

                </BaseButton>

                <BaseButton @click="handleExportStackEdit" data-testid="submenu-tools-export-stackedit">
                    <FileJson class="w-4 h-4" /><span>Export StackEdit</span>
                </BaseButton>

                <BaseButton @click="handleExportZip" data-testid="submenu-tools-export-markdown">

                    <FolderArchive class="w-4 h-4" /><span>Export Markdown</span>

                </BaseButton>

                <BaseButton @click="goToPrintStyles" data-testid="submenu-tools-print">

                    <Printer class="w-4 h-4" /><span>Print</span>

                </BaseButton>

            </div>
        </div>
    </transition>
</template>

<script setup>
import { ref } from 'vue'
import { useRouter } from 'vue-router'
import { useDocStore } from '@/store/docStore'
import { useUiStore } from '@/store/uiStore'
import BaseButton from '@/components/BaseButton.vue'

import {
    Folder,
    Edit3,
    Eye,
    Palette,
    Bold,
    Italic,
    Strikethrough,
    MessageSquare,
    List,
    ListOrdered,
    CheckSquare,
    Table,
    Code2,
    BarChart2,
    Info,
    Search,
    ArrowRight,
    Upload,
    FileJson,
    FolderArchive,
    Printer,
    Image as ImageIcon,
    Replace
} from 'lucide-vue-next'

const ui = useUiStore()
const docStore = useDocStore()
const router = useRouter()

/* ───────── state ───────── */
const searchTerm = ref('')
const replaceEnabled = ref(false)
const replaceTerm = ref('')
const imageInput = ref(null)

/* ───────── presets ───────── */
const textFormats = [
    { label: 'Bold', icon: Bold, prefix: '**', suffix: '**' },
    { label: 'Italic', icon: Italic, prefix: '_', suffix: '_' },
    { label: 'Strike', icon: Strikethrough, prefix: '~~', suffix: '~~' },
    { label: 'Quote', icon: MessageSquare, prefix: '> ', suffix: '\n' }
]
const listFormats = [
    { label: 'Bullet List', icon: List, prefix: '* ' },
    { label: 'Numbered List', icon: ListOrdered, prefix: '1. ' },
    { label: 'Task List', icon: CheckSquare, prefix: '- [ ] ' }
]

/* ───────── helpers ───────── */
function editorRef() {
    return window.__editorRef || {}
}

function insertFormat(f) {
    editorRef().insertFormat?.(f.prefix, f.suffix)
}
function insertList(l) {
    editorRef().insertList?.(l.prefix)
}
function insertTable() {
    editorRef().insertTable?.()
}
function insertCodeBlock() {
    editorRef().insertCodeBlock?.()
}
function insertImagePlaceholder() {
    editorRef().insertImagePlaceholder?.()
}

function openImageDialog() {
    imageInput.value?.click()
}
function handleImageSelect(e) {
    const file = e.target.files[0]
    if (file) {
        editorRef().uploadImage?.(file)
        e.target.value = ''
    }
}

/* Find / replace */
function findNext(term) {
    editorRef().findNext?.(term)
}
function replaceNext(term, repl) {
    if (!replaceEnabled.value) return
    editorRef().replaceNext?.(term, repl)
}
function replaceAll(term, repl) {
    if (!replaceEnabled.value) return
    editorRef().replaceAll?.(term, repl)
}

/* Navigation & exports */
function goToStyles() {
    router.push('/styles')
}
function goToPrintStyles() {
    router.push('/print-styles')
}
async function handleExport() {
    try {
        const jsonString = await docStore.exportJson()
        const blob = new Blob([jsonString], { type: 'application/json' })
        const url = URL.createObjectURL(blob)
        const a = document.createElement('a')
        a.href = url
        a.download = 'markdown-notes-export.json'
        a.click()
        URL.revokeObjectURL(url)
    } catch (err) {
        console.error(err)
        alert('Failed to export JSON.')
    }
}
async function handleExportStackEdit() {
    try {
        const jsonString = await docStore.exportStackEditJson();
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'panino-stackedit-export.json';
        a.click();
        URL.revokeObjectURL(url);
    } catch (err) {
        console.error(err);
        alert('Failed to export StackEdit JSON.');
    }
}
async function handleExportZip() {
    try {
        await docStore.exportZip()
    } catch (err) {
        console.error(err)
        alert('Failed to export ZIP.')
    }
}
</script>
----- END: /home/kris/Development/panino/frontend/src/components/SubMenuBar.vue -----

----- START: /home/kris/Development/panino/frontend/src/pages/PrintStylesPage.vue -----
<template>
  <StyleCustomizer :config="printStylesConfig">
    <div class="h-full overflow-y-auto ">
      <template v-if="!docStore.selectedFileContent">
        <div class="flex flex-col items-center justify-center h-full text-gray-500">
          <h3 class="text-lg font-semibold mb-2">No Document Selected</h3>
          <p class="mb-4">
            Please select a document from the Documents panel to generate a print
            preview.
          </p>
          <button @click="printStylesConfig.onBack()"
            class="px-4 py-2 bg-gray-800 text-white rounded hover:bg-gray-900">
            Back to Editor
          </button>
        </div>

      </template>

      <iframe v-else-if="pdfUrl" :src="pdfUrl" class="w-full h-full border-none"
        data-testid="pdf-preview-iframe"></iframe>

      <div v-else class="flex items-center justify-center h-full text-gray-500">
        Generating PDF preview...
      </div>
    </div>
  </StyleCustomizer>
</template>

<script setup>
import { ref, watch, onUnmounted } from 'vue';
import { useRouter } from 'vue-router';
import StyleCustomizer from '@/components/StyleCustomizer.vue';
import { useDocStore } from '@/store/docStore';
import { useMarkdownStore } from '@/store/markdownStore';
import { jsPDF } from 'jspdf';
import { useDebounceFn } from '@vueuse/core';

const router = useRouter();
const docStore = useDocStore();
const markdownStore = useMarkdownStore();

// local copy of print styles
const editableStyleMap = ref({});
// generated PDF blob URL
const pdfUrl = ref('');
// rendered HTML string for jsPDF
const renderedHtmlForPdf = ref('');

// debounce PDF regen
const debouncedRegeneratePdf = useDebounceFn(regeneratePdf, 700);

// config object passed into StyleCustomizer
const printStylesConfig = {
  title: 'Customize Print Styles',
  getStyles: () => ({ ...docStore.printStyles }),
  updateStyleAction: docStore.updatePrintStyle,
  getMarkdownIt: docStore.getPrintMarkdownIt,
  styleCategories: {
    'Element Styles': [
      'h1', 'h2', 'h3', 'h4', 'p', 'em', 'strong', 'code', 'blockquote',
      'ul', 'ol', 'li', 'a', 'img', 'table', 'tr', 'th', 'td', 'hr', 'pre'
    ]
  },
  extraFieldsTitle: 'Print Header & Footer Settings',
  extraFields: [
    {
      id: 'googleFontFamily',
      label: 'Google Font Family (e.g., Roboto, Open Sans)',
      type: 'input',
      inputType: 'text',
      modelKey: 'googleFontFamily',
      placeholder: 'e.g., Roboto:wght@400;700'
    },
    {
      id: 'printHeaderHtml',
      label: 'Page Header Text/HTML',
      type: 'textarea',
      modelKey: 'printHeaderHtml',
      rows: 2,
      placeholder: 'Text for page headers. Basic HTML allowed.'
    },
    {
      id: 'headerFontSize',
      label: 'Header Font Size (pt)',
      type: 'input',
      inputType: 'number',
      modelKey: 'headerFontSize',
      placeholder: 'e.g., 10'
    },
    {
      id: 'headerFontColor',
      label: 'Header Font Color',
      type: 'input',
      inputType: 'color',
      modelKey: 'headerFontColor'
    },
    {
      id: 'headerAlign',
      label: 'Header Alignment',
      type: 'select',
      modelKey: 'headerAlign',
      options: [
        { value: 'left', text: 'Left' },
        { value: 'center', text: 'Center' },
        { value: 'right', text: 'Right' }
      ]
    },
    {
      id: 'printFooterHtml',
      label: 'Page Footer Text/HTML',
      type: 'textarea',
      modelKey: 'printFooterHtml',
      rows: 2,
      placeholder:
        'Use %p for current page, %P for total pages (if enabled). Basic HTML allowed.'
    },
    {
      id: 'footerFontSize',
      label: 'Footer Font Size (pt)',
      type: 'input',
      inputType: 'number',
      modelKey: 'footerFontSize',
      placeholder: 'e.g., 10'
    },
    {
      id: 'footerFontColor',
      label: 'Footer Font Color',
      type: 'input',
      inputType: 'color',
      modelKey: 'footerFontColor'
    },
    {
      id: 'footerAlign',
      label: 'Footer Alignment',
      type: 'select',
      modelKey: 'footerAlign',
      options: [
        { value: 'left', text: 'Left' },
        { value: 'center', text: 'Center' },
        { value: 'right', text: 'Right' }
      ]
    },
    {
      id: 'enablePageNumbers',
      label: 'Enable Page Numbers in Footer',
      type: 'checkbox',
      modelKey: 'enablePageNumbers'
    },
    {
      id: 'customCSS',
      label: 'Custom Print CSS',
      type: 'textarea',
      modelKey: 'customCSS',
      rows: 6,
      placeholder:
        '/* Add custom CSS for print styles */\n@media print {\n  body { font-family: Georgia, serif; }\n  .page-break { page-break-before: always; }\n}'
    }
  ],
  resetStyles: () => markdownStore.resetPrintStyles(),
  onBack: () => {
    if (docStore.selectedFileId) {
      router.push(`/?file=${docStore.selectedFileId}`);
    } else {
      router.push('/');
    }
  }
};

// whenever the store’s printStyles change, update our local map & regen HTML
watch(
  () => printStylesConfig.getStyles(),
  async newStyles => {
    editableStyleMap.value = { ...newStyles };
    const md = await printStylesConfig.getMarkdownIt();
    renderedHtmlForPdf.value = docStore.selectedFileContent
      ? md.render(docStore.selectedFileContent)
      : `<div style="color: #6b7280; text-align: center; padding: 2rem;">
           No document selected. Please select a document to print.
         </div>`;
    debouncedRegeneratePdf();
  },
  { deep: true, immediate: true }
);

// regenerate on content change too
watch(() => docStore.selectedFileContent, () => debouncedRegeneratePdf());

// PDF layout constants
const PDF_PAGE_WIDTH_PT = 590.78;
const PDF_PAGE_HEIGHT_PT = 841.89;
const PDF_MARGIN_PT = 36;
const PDF_CONTENT_WIDTH_PT = PDF_PAGE_WIDTH_PT - 116.90 - 2 * PDF_MARGIN_PT;

async function regeneratePdf() {
  if (!docStore.selectedFileContent) {
    if (pdfUrl.value) {
      URL.revokeObjectURL(pdfUrl.value);
      pdfUrl.value = '';
    }
    return;
  }

  const styles = editableStyleMap.value;

  // 1) hidden iframe
  const iframe = document.createElement('iframe');
  iframe.style.width = `${PDF_CONTENT_WIDTH_PT}pt`;
  iframe.style.height = '0px';
  iframe.style.visibility = 'hidden';
  iframe.style.position = 'absolute';
  iframe.style.left = '-9999px';
  document.body.appendChild(iframe);
  const doc = iframe.contentDocument || iframe.contentWindow.document;

  // 2) get Google-Font CSS + TTF blobs
  const { css: gfCss, fonts } = await markdownStore.getGoogleFontData(
    styles.googleFontFamily
  );

  const html = `
    <html><head><style>
      html, body { margin:0; padding:0; box-sizing:border-box; }
      font-family: ${styles.googleFontFamily
      ? `'${styles.googleFontFamily
        .split(':')[0]
        .trim()
        .replace(/\+/g, ' ')}'`
      : ''
    } sans-serif;
      ${styles.customCSS || ''}
      ${gfCss || ''}
    </style></head>
    <body>
      <div class="document-container" style="padding: ${PDF_MARGIN_PT}pt;">
        ${renderedHtmlForPdf.value}
      </div>
    </body></html>
  `;
  doc.open();
  doc.write(html);
  doc.close();

  // 3) build PDF
  const pdf = new jsPDF({ unit: 'pt', format: 'a4' });
  const registered = {};

  // embed each fetched TTF
  for (const f of fonts) {
    try {
      if (f.format?.includes('woff')) continue;
      const name = f.name.replace(/ /g, '_') + `_${f.weight}_${f.style}.ttf`;
      const b64 = f.data.split(',')[1];
      let jsStyle = 'normal';
      if (f.style.includes('italic')) jsStyle = 'italic';
      if (['bold', '700', '800', '900'].includes(`${f.weight}`)) {
        jsStyle = jsStyle === 'italic' ? 'bolditalic' : 'bold';
      }
      pdf.addFileToVFS(name, b64);
      pdf.addFont(name, f.name, jsStyle);
      registered[f.name] = registered[f.name] || {};
      registered[f.name][jsStyle] = f.name;
    } catch (e) {
      console.error(`Failed to register font ${f.name}:`, e);
    }
  }

  try {
    const hdr = styles.printHeaderHtml || '';
    const ftrTpl = styles.printFooterHtml || '';
    const hdrSz = parseFloat(styles.headerFontSize) || 10;
    const ftrSz = parseFloat(styles.footerFontSize) || 10;
    const hdrHt = hdr ? hdrSz * 1.5 : 0;
    const ftrHt = ftrTpl ? ftrSz * 1.5 : 0;

    await pdf.html(doc.body, {
      margin: [PDF_MARGIN_PT + hdrHt, PDF_MARGIN_PT, PDF_MARGIN_PT + ftrHt, PDF_MARGIN_PT],
      width: PDF_CONTENT_WIDTH_PT,
      windowWidth: iframe.contentWindow.innerWidth,
      autoPaging: 'text',
      html2canvas: {
        scale: 1.0,
        backgroundColor: '#ffffff',
        useCORS: true,
        logging: false
      }
    });

    const pageCount = pdf.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
      pdf.setPage(i);

      // choose embedded font if available
      const primary = styles.googleFontFamily
        ? styles.googleFontFamily.split(':')[0].trim().replace(/\+/g, ' ')
        : '';
      const useFont = registered[primary]?.normal ? primary : 'Helvetica';
      pdf.setFont(useFont, 'normal');

      // header
      if (hdr) {
        pdf.setFontSize(hdrSz);
        pdf.setTextColor(styles.headerFontColor || '#000000');
        let x =
          styles.headerAlign === 'center'
            ? PDF_PAGE_WIDTH_PT / 2
            : styles.headerAlign === 'right'
              ? PDF_PAGE_WIDTH_PT - PDF_MARGIN_PT
              : PDF_MARGIN_PT;
        pdf.text(hdr, x, PDF_MARGIN_PT, {
          align: styles.headerAlign || 'center',
          maxWidth: PDF_CONTENT_WIDTH_PT
        });
      }

      // footer
      let ftext = '';
      if (styles.enablePageNumbers && ftrTpl) {
        ftext = ftrTpl
          .replace(/%p/g, `${i}`)
          .replace(/%P/g, `${pageCount}`);
      } else if (ftrTpl) {
        ftext = ftrTpl.replace(/%p/g, '').replace(/%P/g, '').trim();
      }
      if (ftext) {
        pdf.setFontSize(ftrSz);
        pdf.setTextColor(styles.footerFontColor || '#000000');
        let x =
          styles.footerAlign === 'center'
            ? PDF_PAGE_WIDTH_PT / 2
            : styles.footerAlign === 'right'
              ? PDF_PAGE_WIDTH_PT - PDF_MARGIN_PT
              : PDF_MARGIN_PT;
        pdf.text(ftext, x, PDF_PAGE_HEIGHT_PT - PDF_MARGIN_PT, {
          align: styles.footerAlign || 'center',
          maxWidth: PDF_CONTENT_WIDTH_PT
        });
      }
    }

    const blob = pdf.output('blob');
    if (pdfUrl.value) URL.revokeObjectURL(pdfUrl.value);
    pdfUrl.value = URL.createObjectURL(blob);
  } catch (err) {
    console.error('PDF generation failed:', err);
    if (pdfUrl.value) {
      URL.revokeObjectURL(pdfUrl.value);
      pdfUrl.value = '';
    }
    alert(`PDF generation failed: ${err.message}. Check console for details.`);
  } finally {
    if (iframe.parentNode) document.body.removeChild(iframe);
  }
}

onUnmounted(() => {
  if (pdfUrl.value) {
    URL.revokeObjectURL(pdfUrl.value);
  }
});
</script>

<style scoped>
/* everything else inherited from StyleCustomizer */
</style>

----- END: /home/kris/Development/panino/frontend/src/pages/PrintStylesPage.vue -----

----- START: /home/kris/Development/panino/frontend/src/store/docStore.js -----
// /frontend/src/store/docStore.js
import { defineStore } from 'pinia';
import { storeToRefs } from 'pinia';
import { useStructureStore } from './structureStore';
import { useMarkdownStore } from './markdownStore';
import { useSyncStore } from './syncStore';
import { useImportExportStore } from './importExportStore';

export const useDocStore = defineStore('docStore', () => {
    const structureStore = useStructureStore();
    const markdownStore = useMarkdownStore();
    const syncStore = useSyncStore();
    const importExportStore = useImportExportStore();
    // Pull refs out of the other stores WITHOUT wrapping them in computed again
    const {
        selectedFileId,
        selectedFolderId,
        openFolders,
        rootItems,
        selectedFile,
        selectedFileContent
    } = storeToRefs(structureStore);

    const { styles, printStyles } = storeToRefs(markdownStore);

    async function loadInitialData() {
        // This is now mainly for selecting a default file after the initial sync
        await structureStore.loadRootItems(); // Ensure root items are loaded
        if (structureStore.rootItems.length > 0 && !structureStore.selectedFileId) {
            const firstFile = structureStore.rootItems.find(item => item.type === 'file');
            if (firstFile) {
                structureStore.selectFile(firstFile.id);
            }
        }
    }
    async function refreshData() {
        console.log('[DocStore] Refreshing data after sync.');
        await structureStore.loadRootItems();
        if (structureStore.selectedFileId) {
            // This is the key change: explicitly re-fetch the current file's data
            await structureStore.reFetchSelectedFile();
        }
    }

    async function resetStore() {
        await syncStore.resetDatabase();
        structureStore.resetStore();
        markdownStore.resetStyles();
        markdownStore.resetPrintStyles();
        console.log('All stores have been reset.');
    }

    async function getRecentDocuments(limit = 10) {
        const query = `SELECT id, title as name, updated_at as displayedDate FROM notes ORDER BY updated_at DESC LIMIT ?`;
        try {
            // CORRECTED: The result is the array itself
            const results = await syncStore.execute(query, [limit]);
            return results || [];
        } catch (error) {
            console.error('Failed to get recent documents:', error);
            return [];
        }
    }

    return {
        // State & Getters (forwarded refs)
        selectedFileId,
        selectedFolderId,
        openFolders,
        styles,
        printStyles,
        rootItems,
        selectedFile,
        selectedFileContent,

        // Expose stores if you still need direct access
        structureStore,
        syncStore,
        markdownStore,

        // Actions from structureStore
        loadInitialData,
        resetStore,
        loadRootItems: structureStore.loadRootItems,
        getChildren: structureStore.getChildren,
        createFile: structureStore.createFile,
        createFolder: structureStore.createFolder,
        deleteItem: structureStore.deleteItem,
        renameItem: structureStore.renameItem,
        moveItem: structureStore.moveItem,
        selectFile: structureStore.selectFile,
        selectFolder: structureStore.selectFolder,
        toggleFolder: structureStore.toggleFolder,
        updateFileContent: structureStore.updateFileContent,

        // Actions from other stores
        exportJson: importExportStore.exportDataAsJsonString,
        exportZip: importExportStore.exportDataAsZip,
        importData: importExportStore.importData,
        exportStackEditJson: importExportStore.exportDataAsStackEditJsonString,
        importStackEditData: importExportStore.importStackEditData,

        updateStyle: markdownStore.updateStyle,
        getMarkdownIt: markdownStore.getMarkdownIt,
        updatePrintStyle: markdownStore.updatePrintStyle,
        getPrintMarkdownIt: markdownStore.getPrintMarkdownIt,
        getRecentDocuments,
        refreshData, // Expose the new function

    };
});
----- END: /home/kris/Development/panino/frontend/src/store/docStore.js -----

----- START: /home/kris/Development/panino/frontend/src/store/markdownStore.js -----
// /frontend/src/store/markdownStore.js
import { defineStore } from 'pinia'
import { ref, watch } from 'vue'
import MarkdownIt from 'markdown-it'
import markdownItTaskLists from 'markdown-it-task-lists'
import { useSyncStore } from './syncStore'
import { fetchGoogleFontTtf } from '@/utils/googleFontTtf.js'

export const useMarkdownStore = defineStore('markdownStore', () => {
    const syncStore = useSyncStore();


    /* ------------------------------------------------------------------
     * 1) Preview styles (improved defaults)
     * ----------------------------------------------------------------*/
    const defaultStyles = {
        h1: 'font-family: "Playfair Display", "Source Sans 3", Georgia, serif; font-size: 2.25rem; line-height: 1.15; color: #111827; margin-top: 2.5rem; margin-bottom: 1rem; font-weight: 600;',
        h2: 'font-family: "Playfair Display", "Source Sans 3", Georgia, serif; font-size: 1.75rem; line-height: 1.2; color: #1f2937; margin-top: 2rem; margin-bottom: .75rem; font-weight: 600;',
        h3: 'font-size: 1.5rem; line-height: 1.25; color: #1f2937; margin-top: 1.5rem; margin-bottom: .5rem; font-weight: 600;',
        h4: 'font-size: 1.25rem; line-height: 1.3; color: #374151; margin-top: 1.25rem; margin-bottom: .5rem; font-weight: 600;',
        h5: 'font-size: 1rem; line-height: 1.4; margin-top: 1rem; margin-bottom: .25rem; font-weight: 600; color: #374151;',
        h6: 'font-size: .875rem; line-height: 1.4; margin-top: 1rem; margin-bottom: .25rem; font-weight: 600; text-transform: uppercase; letter-spacing: .03em; color: #4b5563;',
        p: 'margin: 0 0 1rem 0; line-height: 1.55;',
        ul: 'list-style-type: disc; margin: 0 0 1rem 1.5rem; padding: 0;',
        ol: 'list-style-type: decimal; margin: 0 0 1rem 1.5rem; padding: 0;',
        li: 'margin: .25rem 0;',
        code: 'font-family: "JetBrains Mono", ui-monospace, monospace; background-color: #f3f4f6; color: #111827; padding: .1rem .35rem; border-radius: 4px; font-size: .875em; font-variant-ligatures: none;',
        pre: 'display: block; width: 100%; box-sizing: border-box; font-family: "JetBrains Mono", ui-monospace, monospace; background-color: #f3f4f6; color: #111827; padding: 1rem 1.25rem; border-radius: 8px; overflow: auto; font-size: .875rem; line-height: 1.5; margin: 1.5rem 0; font-variant-ligatures: none;',
        blockquote: 'margin: 1.5rem 0; padding: .5rem 1rem; border-left: 4px solid #d1d5db; background-color: rgba(209, 213, 219, 0.08);',
        hr: 'border: 0; border-top: 1px solid #d1d5db; margin: 2rem 0;',
        em: 'font-style: italic;',
        strong: 'font-weight: 600;',
        a: 'color: #2563eb; text-decoration: underline; text-underline-offset: 2px;',
        img: 'max-width: 100%; height: auto; border-radius: 4px; margin: 1rem 0;',
        table: 'width: 100%; border-collapse: collapse; margin: 1.5rem 0; font-size: .875rem;',
        tr: 'border-bottom: 1px solid #e5e7eb;',
        th: 'border: 1px solid #d1d5db; background-color: #f3f4f6; padding: .5rem .75rem; text-align: left; font-weight: 600;',
        td: 'border: 1px solid #d1d5db; padding: .5rem .75rem;',
        customCSS: `
#preview-content, [data-testid="preview-content"] {
    max-width: 72ch;
    margin-left: auto;
    margin-right: auto;
    font-variant-numeric: proportional-nums;
}
/* Un-style code blocks inside <pre> so they inherit the parent's style */
pre > code {
    background: transparent;
    padding: 0;
    border-radius: 0;
    font-size: 1em;
}
`,
        googleFontFamily: 'Source Sans 3, JetBrains Mono, Playfair Display',
    };


    const defaultPrintStyles = {
        // Migrated from defaultStyles for consistency
        h1: ' font-size: 2.25rem; orphans: 3; widows: 3;  line-height: 1.15; color: #111827; margin-top: 2.5rem; margin-bottom: 1rem; font-weight: 600;',
//         h2: 'font-family: "Playfair Display", "Source Sans 3", Georgia, serif; font-size: 1.75rem; line-height: 1.2; color: #1f2937; margin-top: 2rem; margin-bottom: .75rem; font-weight: 600;',
//         h3: 'font-size: 1.5rem; line-height: 1.25; color: #1f2937; margin-top: 1.5rem; margin-bottom: .5rem; font-weight: 600;',
//         h4: 'font-size: 1.25rem; line-height: 1.3; color: #374151; margin-top: 1.25rem; margin-bottom: .5rem; font-weight: 600;',
//         h5: 'font-size: 1rem; line-height: 1.4; margin-top: 1rem; margin-bottom: .25rem; font-weight: 600; color: #374151;',
//         h6: 'font-size: .875rem; line-height: 1.4; margin-top: 1rem; margin-bottom: .25rem; font-weight: 600; text-transform: uppercase; letter-spacing: .03em; color: #4b5563;',
//         p: 'margin: 0 0 1rem 0; line-height: 1.55;',
//         ul: 'list-style-type: disc; margin: 0 0 1rem 1.5rem; padding: 0;',
//         ol: 'list-style-type: decimal; margin: 0 0 1rem 1.5rem; padding: 0;',
//         li: 'margin: .25rem 0;',
//         code: 'font-family: "JetBrains Mono", ui-monospace, monospace; background-color: #f3f4f6; color: #111827; padding: .1rem .35rem; border-radius: 4px; font-size: .875em; font-variant-ligatures: none;',
//         pre: 'display: block; width: 100%; box-sizing: border-box; font-family: "JetBrains Mono", ui-monospace, monospace; background-color: #f3f4f6; color: #111827; padding: 1rem 1.25rem; border-radius: 8px; overflow: auto; font-size: .875rem; line-height: 1.5; margin: 1.5rem 0; font-variant-ligatures: none;',
//         blockquote: 'margin: 1.5rem 0; padding: .5rem 1rem; border-left: 4px solid #d1d5db; background-color: rgba(209, 213, 219, 0.08);',
//         hr: 'border: 0; border-top: 1px solid #d1d5db; margin: 2rem 0;',
//         em: 'font-style: italic;',
//         strong: 'font-weight: 600;',
//         a: 'color: #2563eb; text-decoration: underline; text-underline-offset: 2px;',
//         img: 'max-width: 100%; height: auto; border-radius: 4px; margin: 1rem 0; page-break-inside: avoid;',
//         table: 'width: 100%; border-collapse: collapse; margin: 1.5rem 0; font-size: .875rem; page-break-inside: avoid;',
//         tr: 'border-bottom: 1px solid #e5e7eb; page-break-inside: avoid;',
//         th: 'border: 1px solid #d1d5db; background-color: #f3f4f6; padding: .5rem .75rem; text-align: left; font-weight: 600;',
//         td: 'border: 1px solid #d1d5db; padding: .5rem .75rem;',

        // Print-specific header/footer settings
        printHeaderHtml: "Professional Document",
        printFooterHtml: "Page %p of %P",
        headerFontSize: "10",
        headerFontColor: "#666666",
        headerAlign: "center",
        footerFontSize: "10",
        footerFontColor: "#666666",
        footerAlign: "center",
        enablePageNumbers: true,
        googleFontFamily: 'Source Sans 3, JetBrains Mono, Playfair Display',

        // Cleaned-up custom CSS for printing
        customCSS: `
/* Set base font size for the print document */
@media print {
  body {
    font-size: 11pt;
    line-height: 1.6;
  }
}
/* Un-style code blocks inside <pre> so they inherit the parent's style */
pre > code {
  background: transparent;
  padding: 0;
  border-radius: 0;
  font-size: 1em;
  color: inherit;
}
/* Page breaking rules for better layout */
h1, h2, h3, h4, h5, h6 {
  page-break-after: avoid;
  page-break-inside: avoid;
}
ul, ol, table, figure, img, blockquote, pre {
  page-break-inside: avoid;
}
.page-break {
  page-break-before: always;
}
`,
    };

    const styles = ref({ ...defaultStyles });
    const printStyles = ref({ ...defaultPrintStyles });
    const fontCache = ref(new Map());
    let settingsLoaded = false;

    // Debounce DB writes
    const debounce = (fn, wait) => {
        let t;
        return (...args) => {
            clearTimeout(t);
            t = setTimeout(() => fn(...args), wait);
        };
    };

    const saveStylesToDB = debounce(async () => {
        if (!settingsLoaded || !syncStore.isInitialized) return;
        try {
            await syncStore.db.value.exec('BEGIN TRANSACTION;');
            await syncStore.db.value.exec(
                'INSERT OR REPLACE INTO settings (id, value) VALUES (?, ?)',
                ['previewStyles', JSON.stringify(styles.value)]
            );
            await syncStore.db.value.exec(
                'INSERT OR REPLACE INTO settings (id, value) VALUES (?, ?)',
                ['printStyles', JSON.stringify(printStyles.value)]
            );
            await syncStore.db.value.exec('COMMIT;');
        } catch (err) {
            await syncStore.db.value.exec('ROLLBACK;');
            console.error('[markdownStore] Failed to save styles', err);
        }
    }, 500);

    async function loadStylesFromDB() {
        if (!syncStore.isInitialized) return;
        try {
            const result = await syncStore.execute(`SELECT id, value FROM settings WHERE id IN ('previewStyles', 'printStyles')`);
            const loadedSettings = result || [];

            const preview = loadedSettings.find(s => s.id === 'previewStyles');
            if (preview) Object.assign(styles.value, JSON.parse(preview.value));

            const print = loadedSettings.find(s => s.id === 'printStyles');
            if (print) Object.assign(printStyles.value, JSON.parse(print.value));

            settingsLoaded = true;
        } catch (err) {
            console.error('[markdownStore] Failed to load styles', err);
            settingsLoaded = true; // Avoid getting stuck
        }
    }

    // Watch for DB initialization to load settings
    watch(() => syncStore.isInitialized, (ready) => {
        if (ready) loadStylesFromDB();
    }, { immediate: true });

    // Actions
    function updateStyle(key, value) {
        if (styles.value[key] !== undefined) {
            styles.value[key] = value;
            saveStylesToDB();
        }
    }

    function updatePrintStyle(key, value) {
        if (printStyles.value[key] !== undefined) {
            printStyles.value[key] = value;
            saveStylesToDB();
        }
    }

    function resetStyles() {
        styles.value = { ...defaultStyles };
        saveStylesToDB();
    }

    function resetPrintStyles() {
        printStyles.value = { ...defaultPrintStyles };
        saveStylesToDB();
    }

    /**
     * Fetch Google Font CSS (for the live HTML preview) **and**
     * Base-64-encoded TTF binaries (for jsPDF embedding).
     *
     * @param {string} fontFamily – "Roboto" or "Inter, Open Sans" (comma-separated list)
     * @return {Promise<{css:string, fonts:Array<{name,data,format,style,weight}>}>}
     */
    async function getGoogleFontData(fontFamily) {
        if (!fontFamily || !fontFamily.trim()) {
            return { css: '', fonts: [] }
        }

        if (fontCache.value.has(fontFamily)) {
            return fontCache.value.get(fontFamily)
        }

        try {
            // Split comma-separated font families and process each
            const fontFamilies = fontFamily.split(',').map(f => f.trim()).filter(f => f)
            const allFonts = []
            const fontImports = []

            for (const singleFamily of fontFamilies) {
                // Skip generic font families
                if (['serif', 'sans-serif', 'monospace', 'cursive', 'fantasy'].includes(singleFamily.toLowerCase())) {
                    continue
                }

                // Remove quotes if present
                const cleanFamily = singleFamily.replace(/['"]/g, '')

                /* ---------- 1. Grab TTF URLs from your server ---------- */
                const variants = await fetchGoogleFontTtf(cleanFamily)

                for (const v of variants) {
                    const key = `${v.family}-${v.weight}-${v.style}`
                    if (fontCache.value.has(key)) {
                        allFonts.push(fontCache.value.get(key))
                        continue
                    }

                    const blob = await fetch(v.url).then(r => r.blob())
                    const base64 = await new Promise((resolve, reject) => {
                        const reader = new FileReader()
                        reader.onloadend = () => resolve(reader.result)
                        reader.onerror = reject
                        reader.readAsDataURL(blob)
                    })

                    const fontObj = {
                        name: v.family,
                        data: base64,          // data:…;base64,
                        format: 'truetype',
                        style: v.style,
                        weight: v.weight,
                    }

                    fontCache.value.set(key, fontObj) // cache each variant
                    allFonts.push(fontObj)
                }

                // Add to CSS imports (encode font name for Google Fonts URL)
                const encodedFamily = encodeURIComponent(cleanFamily)
                fontImports.push(`family=${encodedFamily}:wght@400;600;700`)
            }

            /* ---------- 2. CSS import for the live preview iframe ------------- */
            const css = fontImports.length > 0
                ? `@import url('https://fonts.googleapis.com/css2?${fontImports.join('&')}&display=swap');`
                : ''

            const result = { css, fonts: allFonts }
            fontCache.value.set(fontFamily, result)
            return result
        } catch (err) {
            console.error('[markdownStore] Google-Font fetch failed', err)
            return { css: '', fonts: [] }
        }
    }

    /**
     * ✅ ADDED: Helper function to create a base instance of MarkdownIt with common plugins.
     */
    const baseMd = () => {
        return new MarkdownIt({
            html: true,
            linkify: true,
            typographer: true,
        }).use(markdownItTaskLists);
    };

    /**
     * ✅ ADDED: Injects a string of CSS into a <style> tag in the document's <head>.
     * This is used for applying custom user styles for the preview.
     * @param {string} cssContent The CSS rules to inject.
     * @param {Document} targetDoc The document to inject into (defaults to window.document).
     */
    function addCustomCSSToDocument(cssContent, targetDoc = document) {
        const styleId = 'markdown-custom-styles';
        let styleElement = targetDoc.getElementById(styleId);
        if (!styleElement) {
            styleElement = targetDoc.createElement('style');
            styleElement.id = styleId;
            targetDoc.head.appendChild(styleElement);
        }
        // This will overwrite previous custom styles, which is intended
        // as this is part of a full re-render cycle.
        styleElement.textContent = cssContent;
    }


    function configureRenderer(md, styleMap) {
        let combinedCSS = '';
        if (styleMap.customCSS) {
            combinedCSS += styleMap.customCSS;
        }
        // ✅ FIXED: Also apply Google Fonts for the main preview, not just print.
        if (styleMap.googleFontFamily) {
            const families = styleMap.googleFontFamily.split(',')
            	.map(f => `family=${encodeURIComponent(f.trim())}:wght@400;600;700`)
            	.join('&');
            if (families) {
            	combinedCSS += `@import url('https://fonts.googleapis.com/css2?${families}&display=swap');\n`;
            	const primaryFont = styleMap.googleFontFamily.split(',')[0].trim().replace(/['"]/g, '');
            	// This font-family rule will apply to the preview containers
            	combinedCSS += `
            		#preview-content, [data-testid="preview-content"] {
            			font-family: "${primaryFont}", system-ui, sans-serif;
            		}
            	`;
            }
        } else if (styleMap.googleFontData && styleMap.googleFontData.css) {
            combinedCSS += styleMap.googleFontData.css;
        }

        if (combinedCSS) {
            addCustomCSSToDocument(combinedCSS);
        }

        // Headings
        md.renderer.rules.heading_open = (tokens, idx, opts, env, self) => {
            const token = tokens[idx]
            const css = styleMap[token.tag]
            if (css) {
                token.attrSet('style', css)
            }
            return self.renderToken(tokens, idx, opts)
        }

        // Paragraphs
        const defPara = md.renderer.rules.paragraph_open || ((t, i, o, e, s) => s.renderToken(t, i, o))
        md.renderer.rules.paragraph_open = (tokens, idx, opts, env, self) => {
            const css = styleMap.p
            if (css) {
                tokens[idx].attrSet('style', css)
            }
            return defPara(tokens, idx, opts, env, self)
        }

        // Lists
        md.renderer.rules.bullet_list_open = (t, i, o, e, s) => {
            const css = styleMap.ul
            if (css) t[i].attrSet('style', css)
            return s.renderToken(t, i, o)
        }
        md.renderer.rules.ordered_list_open = (t, i, o, e, s) => {
            const css = styleMap.ol
            if (css) t[i].attrSet('style', css)
            return s.renderToken(t, i, o)
        }
        const defLi = md.renderer.rules.list_item_open || ((t, i, o, e, s) => s.renderToken(t, i, o))
        md.renderer.rules.list_item_open = (tokens, idx, opts, env, self) => {
            const css = styleMap.li
            if (css) tokens[idx].attrSet('style', css)
            return defLi(tokens, idx, opts, env, self)
        }

        // Inline code
        const defCodeInline = md.renderer.rules.code_inline || ((t, i, o, e, s) => s.renderToken(t, i, o))
        md.renderer.rules.code_inline = (t, i, o, e, s) => {
            const css = styleMap.code
            if (css) t[i].attrSet('style', css)
            return defCodeInline(t, i, o, e, s)
        }

        // Code blocks
        const defFence = md.renderer.rules.fence || ((t, i, o, e, s) => s.renderToken(t, i, o))
        md.renderer.rules.fence = (t, i, o, e, s) => {
            const css = styleMap.pre
            if (css) t[i].attrSet('style', css)
            return defFence(t, i, o, e, s)
        }
        const defCodeBlock = md.renderer.rules.code_block || ((t, i, o, e, s) => s.renderToken(t, i, o))
        md.renderer.rules.code_block = (t, i, o, e, s) => {
            const css = styleMap.pre
            if (css) t[i].attrSet('style', css)
            return defCodeBlock(t, i, o, e, s)
        }

        // Blockquote
        md.renderer.rules.blockquote_open = (t, i, o, e, s) => {
            const css = styleMap.blockquote
            if (css) t[i].attrSet('style', css)
            return s.renderToken(t, i, o)
        }

        // HR
        md.renderer.rules.hr = (t, i, o, e, s) => {
            const css = styleMap.hr
            if (css) t[i].attrSet('style', css)
            return s.renderToken(t, i, o)
        }

        // Em / strong
        md.renderer.rules.em_open = (t, i, o, e, s) => {
            const css = styleMap.em
            if (css) t[i].attrSet('style', css)
            return s.renderToken(t, i, o)
        }
        md.renderer.rules.strong_open = (t, i, o, e, s) => {
            const css = styleMap.strong
            if (css) t[i].attrSet('style', css)
            return s.renderToken(t, i, o)
        }

        // Links
        md.renderer.rules.link_open = (t, i, o, e, s) => {
            const css = styleMap.a
            if (css) t[i].attrSet('style', css)
            const href = t[i].attrGet('href')
            if (href && (href.startsWith('http') || href.startsWith('//'))) {
                t[i].attrSet('target', '_blank')
                t[i].attrSet('rel', 'noopener noreferrer')
            }
            return s.renderToken(t, i, o)
        }

        // Images
        md.renderer.rules.image = (t, i, o, e, s) => {
            const css = styleMap.img
            if (css) t[i].attrSet('style', css)
            t[i].attrSet('loading', 'lazy')
            return s.renderToken(t, i, o)
        }

        // Tables
        md.renderer.rules.table_open = (t, i, o, e, s) => {
            const css = styleMap.table
            if (css) t[i].attrSet('style', css)
            return s.renderToken(t, i, o)
        }
        md.renderer.rules.tr_open = (t, i, o, e, s) => {
            const css = styleMap.tr
            if (css) t[i].attrSet('style', css)
            return s.renderToken(t, i, o)
        }
        md.renderer.rules.th_open = (t, i, o, e, s) => {
            const css = styleMap.th
            if (css) t[i].attrSet('style', css)
            return s.renderToken(t, i, o)
        }
        md.renderer.rules.td_open = (t, i, o, e, s) => {
            const css = styleMap.td
            if (css) t[i].attrSet('style', css)
            return s.renderToken(t, i, o)
        }
    }

    function getMarkdownIt() {
        const md = baseMd()
        configureRenderer(md, styles.value)
        return md
    }

    async function getPrintMarkdownIt() {
        const md = baseMd()
        // Fetch and embed Google Fonts for print if specified
        const googleFontData = await getGoogleFontData(printStyles.value.googleFontFamily);
        const printStyleMap = { ...printStyles.value, googleFontData };
console.log(md)
        configureRenderer(md, printStyleMap);
        return md
    }
    return {
        styles, printStyles,
        updateStyle, updatePrintStyle,
        resetStyles, resetPrintStyles,
        getMarkdownIt, getPrintMarkdownIt,
        getGoogleFontData
    };
});
----- END: /home/kris/Development/panino/frontend/src/store/markdownStore.js -----

----- START: /home/kris/Development/panino/frontend/src/utils/googleFontTtf.js -----
// frontend/src/utils/googleFontTtf.js

/**
 * Runtime helper that always returns direct `.ttf` URLs for the
 * requested Google Font family by querying the public
 * "google-webfonts-helper" JSON API.
 *
 * @param {string} family   e.g. "Roboto" or "Open Sans"
 * @param {string[]} variants  defaults to the four most common
 * @param {string[]} subsets   defaults to ["latin"]
 * @returns {Promise<Array<{ family:string, weight:string, style:string, url:string }>>}
 */
export async function fetchGoogleFontTtf(
    family,
    variants = ['regular', '700', 'italic', '700italic'],
    subsets = ['latin'],
) {

    const isProduction = import.meta.env.PROD
    const devFontServiceUrl =
        import.meta.env.VITE_FONT_SERVICE_URL || 'http://localhost:3002'
    const fontServiceUrl = isProduction ? '' : devFontServiceUrl

    const id = family.trim().toLowerCase().replace(/\s+/g, '-');
    const url = `${fontServiceUrl}/gwf/${id}?variants=${variants.join(',')}&subsets=${subsets.join(',')}&formats=ttf`;

    const res = await fetch(url, { mode: 'cors' });
    if (!res.ok) {
        throw new Error(`gwfh error: ${res.status} ${res.statusText}`);
    }

    const json = await res.json();           // API response schema:
    // https://github.com/majodev/google-webfonts-helper#api
    return json.variants.map(v => ({
        family: json.family,   // "Roboto", "Inter" ...
        weight: v.fontWeight,  // "400" | "700" | ...
        style: v.fontStyle,   // "normal" | "italic"
        url: v.ttf,         // direct .ttf URL
    }));
}
----- END: /home/kris/Development/panino/frontend/src/utils/googleFontTtf.js -----

